### 1. 左值与右值概念

+ 左值（lvalue）：表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。
+ 右值（rvalue）：则使用排除法来定义，一个表达式不是左值就是右值。那么，右值是一个不表示内存中某个可识别位置的对象的表达式。

### 2. 左值与右值之间的转换
+ 通常来说，计算对象的值的语言成分，都使用右值作为参数。例如，两元加法操作符'+'就需要两个右值参数，并返回一个右值
    ```cpp
    int a = 1;           //a是左值
    int b = 2;           //b是右值
    int c = a + b;       //需要右值，所以a和b被转换成右值，+返回右值
    ```
    在例子中，a 和 b 都是左值。因此，在第三行中，它们经历了隐式的 左值到右值转换 。除了数组、函数、不完整类型的所有左值都可以转换为右值。

    那么右值可以转换为左值呢？当然不能！根据左值的定义，这违反了左值的本质。【注：右值可以显式地赋值给左值。之所以没有隐式的转换，是因为右值不能使用在左值应当出现的位置。】

+ 右值可以通过一些更显式的方法产生左值。例如，一元解引用操作符 '*' 需要一个右值参数，但返回一个左值结果。考虑这样的代码：
    
    ```cpp
    int arr[] = {1, 2};
    int* p = &arr[0];
    *(p + 1) = 10;   // 正确: p + 1 是右值，但 *(p + 1) 是左值
    ```
    
+ 相反的，一元取地址操作符 '&' 需要一个左值参数，返回一个右值：
    ```cpp
    int var = 10;
    int* bad_addr = &(var + 1); // 错误: 一元 '&' 操作符需要左值参数
    int* addr = &var;           // 正确: var 是左值
    &var = 40;                  // 错误: 赋值操作的左操作数需要是左值
    ```
+ 在 C++ 中 '&' 符号还有另一个功能——定义引用类型。引用类型又叫做“左值引用”。因此，不能将一个右值赋值给（非常量的）左值引用：
    ```cpp
    std::string& sref = std::string();  // 错误: 非常量的引用 'std::string&' 错误地使用右值 'std::string` 初始化
    ```
### 3. C++11右值引用

具体见：[理解 C/C++ 中的左值和右值](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)