### 1. 指针的引用的区别

+ 指针有自己的一块空间，而引用只是一个别名
+ 使用sizeof看一个指针大小为4，而引用则是被引用对象的大小
+ 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用
+ 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象
+ 可以有const指针，但没有const引用
+ 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能改变
+ 指针可以有多级指针，如（**p），而引用只有一级
+ 指针和引用使用++运算符意义不同
+ 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏

### 2. 指针与数组

C++程序中，真是和数组在不少地方可以相互替换着用，让人差生一种错觉，以为两者是等价的。

+ 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变。

+ 指针可以随时只想任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。

**指针与数组的主要区别如下：**
+ 数组与指针的内存空间关系：
    + 数组一般在栈区开辟空间，也可以在静态区开辟空间（全局数组，静态数组），空间的开辟于回收都由编译器或操作系统来完成，不需要程序员手动执行，不会产生内存泄漏。

    + 指针首先是一个变量。指针通常指向一块动态开辟的空间，需要使用malloc或者new开辟，指针变量的值保存的是在堆上开辟空间的首地址。不再使用指针时，需使用free或delete手动释放内存，否则会造成内存泄漏。

+ 修改内容
数组和指针虽然都可以用一个字符串来初始化，尽管看上去一样，但底层机制却不同。例如：
    ```cpp
    int main()
    {
        char arr[] = "hello";
        cout << arr << endl;
        arr[1] = 'E';    //OK  "hEllo\0"

        char *p = "hello";
        cout << p << endl;
        p[1] = 'E';    //Error
        return 0;
    }
    ```
    从内存的角度来理解其区别：
    + char *p是一个指针，根本没有涉及到内存分配，它指向的“hello”是只读的，若试图去给它赋值必然发生错误。这里的“hello”是字符串常量，存储在常量区，char *p只是提供了一个指向该内存的指针。
    + char arr[]是一个数组，它在堆栈中已经分配好内存，将“hello”复制到该内存块中。

+ 计算大小：
    ```cpp
    int main()
    {
        int arr[4] = {1, 2, 3, 4};
        cout << sizeof(arr) << endl;   //16
        int *p = new int[4];
        cout << sizeof(p) << endl;     //4
        return 0;
    }
    ```
    用sizeof运算符可以计算出数组的容量（字节数）。上述中，sizeof(arr)得到的大小为数组的真实大小，而sizeof(p)得到的只是指针的大小（在32位系统上，指针大小为4）。

+ 数组作为函数参数：
    + 把数组作为参数传递的时候，会退化为指针。数组名作为函数形参时，在函数体内，其实去了本身的内涵，仅仅只是一个指针；很遗憾，在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。
    + 数组名可以作为指针常量。虽然数组名可以转换为指向其指代实体的指针，但是它只能被看作一个指针常量，不能被修改。
