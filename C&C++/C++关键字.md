### 1. const关键字

+ 1.1 不考虑类的情况
    + const常量在定义时必须被初始化，之后无法更改
    + const形参可以接受const和非const类型的实参，如：
        ```cpp
        void fun(const int& i){}    //可以是int类型或者const int类型
        ```
+ 1.2 考虑类
    + const成员变量：不能再类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能再类中声明时初始化。
    + const成员函数：放在函数名后面，大括号前面。表明这个函数是不能改变类的成员变量的（加了mutable修饰的除外）。详细如下图所示：
    ![](https://raw.githubusercontent.com/fengz63/picture/main/20210326152237.png)

### 2. 顶层const和底层const

+ 2.1  顶层const
    指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边。
    ```cpp
    int *const p2;
    ```
    const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量

+ 2.2 底层const
    指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边。
    ```cpp
    const int *p2;
    int const *p2;
    ```
    两种情况中const修饰\*p2，所以理解为\*p2的值不可以改变，即不可以给\*p2赋值改变p2指向变量的值，但可以通过给p2赋值不同的地址改变这个指针指向。
    例：
    ```cpp
    int a = 10;
	int* const b1 = &a;        //顶层const，b1本身是一个常量
	const int* b2 = &a;        //底层const，b2本身可变，所指的对象是常量
	const int b3 = 20;         //顶层const，b3是常量不可变
	const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
    const int& b5 = a;           //用于声明引用变量，都是底层const
    ```

### 3. define与const的区别

+ a. 编译阶段：define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用
+ b. 安全性：
    1) define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般是最好加上一个大括号包住全部内容，要不然很容易出错
    2) const常常有数据类型，编译器可以对其进行类型安全检查
+ c. 内存占用：
    1) define只是将宏名称进行替换，在内存中会产生多份相同的备份；const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果放入常量表
    2) 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
    
    3) 宏不检查类型；const会检查数据类型。
    
    4) 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

### 4. define与inline区别

+ a. 内联函数在编译时展开，宏在预编译时展开
+ b. 内联函数直接嵌入到目标代码中，宏是简单的做文本替换
+ c. 内联函数有类型检查、语法判断等功能，而宏没有
+ d. 内联函数是函数，宏不是
+ e. 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
+ f. 内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高
