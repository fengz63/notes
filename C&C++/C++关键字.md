### 1. const关键字

+ 1.1 不考虑类的情况
    + const常量在定义时必须被初始化，之后无法更改
    + const形参可以接受const和非const类型的实参，如：
        ```cpp
        void fun(const int& i){}    //可以是int类型或者const int类型
        ```
+ 1.2 考虑类
    + const成员变量：不能再类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能再类中声明时初始化。
    + const成员函数：放在函数名后面，大括号前面。表明这个函数是不能改变类的成员变量的（加了mutable修饰的除外）。详细如下图所示：
    ![](https://raw.githubusercontent.com/fengz63/picture/main/20210326152237.png)

### 2. 顶层const和底层const

+ 2.1  顶层const
    指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边。
    ```cpp
    int *const p2;
    ```
    const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量

+ 2.2 底层const
    指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边。
    ```cpp
    const int *p2;
    int const *p2;
    ```
    两种情况中const修饰\*p2，所以理解为\*p2的值不可以改变，即不可以给\*p2赋值改变p2指向变量的值，但可以通过给p2赋值不同的地址改变这个指针指向。
    例：
    ```cpp
    int a = 10;
	int* const b1 = &a;        //顶层const，b1本身是一个常量
	const int* b2 = &a;        //底层const，b2本身可变，所指的对象是常量
	const int b3 = 20;         //顶层const，b3是常量不可变
	const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
    const int& b5 = a;           //用于声明引用变量，都是底层const
    ```

### 3. define与const的区别

+ a. 编译阶段：define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用
+ b. 安全性：
    1) define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般是最好加上一个大括号包住全部内容，要不然很容易出错
    2) const常常有数据类型，编译器可以对其进行类型安全检查
+ c. 内存占用：
    1) define只是将宏名称进行替换，在内存中会产生多份相同的备份；const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果放入常量表
    2) 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
    
    3) 宏不检查类型；const会检查数据类型。
    
    4) 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

### 4. define与inline区别

+ a. 内联函数在编译时展开，宏在预编译时展开
+ b. 内联函数直接嵌入到目标代码中，宏是简单的做文本替换
+ c. 内联函数有类型检查、语法判断等功能，而宏没有
+ d. 内联函数是函数，宏不是
+ e. 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
+ f. 内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高


### 5. static关键字

+ 1. 静态成员变量
    在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员。静态成员变量有以下几个特点：
    + 静态成员变量是**该类的所有对象所共有的**。对于普通成员变量，每个类的对象都有自己的一份拷贝，而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。
    + 静态成员变量存储在全局数据区。static成员变量的内存空间在初始化时分配。静态成员变量必须初始化，而且只能在类外进行，否则编译能通过，链接不能通过。
    + static成员变量和普通static变量一样，编译时在静态数据区分配内存，到程序结束时才释放。

    何时采用静态数据成员？

    设置静态成员这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。如果想在**同类的多个对象之间实现数据共享，又不要用全局变量**，那么就可以使用静态成员变量。也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。

+ 2. 静态成员函数
    与静态成员变量类似，我们也可以声明一个静态成员函数。静态成员函数为类服务，而不是为某一个类的具体对象服务。静态成员函数与静态成员变量一样，都是类的内部实现，属于类定义的一部分。普通成员函数必须具体作用于某个对象，而静态成员函数并不作用与某个对象。
    静态成员函数的特点：
        + 静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数。
        + 静态成员函数不能访问非静态成员函数和非静态成员变量；
        + 非静态成员函数可以任意的访问静态成员函数和静态数据成员；
        + 由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；
        + 调用静态成员函数，两种方式：
            + a. 通过成员访问操作符（.）和（->），也即通过类对象或只想类对象的指针调用静态成员函数。
            + b. 直接通过类来调用静态成员函数。如<类名>:<静态成员函数名>

+ 3. 面向过程的静态全局变量

        在全局变量前加上关键字static，该变量就被设定为一个静态全局变量。
    静态全局变量有一下特点：
        + 该变量在**全局数据区分配内存**
        + 未经初始化的静态全局变量会被程序**自动初始化为0**.
        + 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。
        + 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。

+ 4. （面向过程）的静态局部变量
    在局部变量前，加上关键字static，该变量就被定为成为一个静态局部变量。通常，在函数体内定义一个变量，每当程序运行到该语句时都会给该局部变量分配内存，但随着程序退出函数体，系统就会收回栈内存，局部变量也会相应失效。<br/>
        但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，这给程序的维护带来不便。<br/>
        静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋值。
        静态局部变量有以下特点：
        + 静态局部变量在全局数据区分配内存。
        + 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化。
        + 静态局部变量一般在声明处初始化，如果没有显示初始化，会被程序自动初始化为0。

+ 5. （面向过程的）静态函数
    在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能**在声明它的文件当中可见，不能被其它文件使用**。
    静态函数的优点：
        + 静态函数不能被其它文件所用
        + 其他文件中可以定义相同名字的函数，不会发生冲突

### 6. volitale关键字
**volatile关键字的作用是让CPU取内存单元中的数据而不是寄存器中的数据**。 如果没有volatile，那么经过编译器优化，CPU会首先访问寄存器中的数据而不是内存单元中的数据（因为访问寄存器会更加快速），这样在多线程环境可能会读取脏数据。

**延伸1：一个参数可以既是const 又是 volatile吗？**

可以，const修饰代表变量只读，volatile修饰代表变量每次都需要从内存中读取。

**延伸2：volatile 可以修饰指针吗？**

可以，代表指针指向的地址是volatile的。

### 7. extern关键字

extern关键字有两个作用：

+ 跟”C”连用时 告诉编译器用C的规则进行编译。因为如果使用C++的规则，由于C++支持函数的重载，所以会将函数名进行修改，导致程序报错。
+ 不与”C”进行连用时 对于变量或函数只进行申明而不是定义，提示编译器该变量或函数的定义需要在另一个文件中寻找。在编译阶段，目标模块A虽然找不到extern 修饰的变量或者函数，但不会报错，而是在链接时从模块B中找到该函数或变量。

### 8. mutable 关键字

mutable是const的反义词，用来突破const的限制。const修饰的成员函数可以修改mutable修饰的成员变量

程序实例
```cpp
class A
{
    mutable int _val = 10;
public:
    void display()const
    {
        _val = 20;
        cout << _val << endl;
    }
};
```
