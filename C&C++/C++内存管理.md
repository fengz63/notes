### 一. C/CPP程序内存结构

一个典型的C程序内存结构包括一下部分：
+ Text segment（代码段）
+ Initialized data segment（初始化数据段）
+ Uninitialized data segment（未初始化数据段，BSS段）
+ Heap（堆区）
+ STack（栈区）

示意图如下所示：

![](https://raw.githubusercontent.com/fengz63/picture/main/memoryLayoutC.jpg)

1. 代码段
    
    代码段包括可执行指令。作为内存中的一个区域，代码段在内存中位于堆或者栈下方，防止堆栈溢出时覆盖掉其内容。

    通常代码段是只读的，以防止程序意外地修改其指令。

2. 已初始化数据段
    
    数据段是程序虚拟地址空间的一部分，它包含已经**初始化的全局变量和静态变量**。数据段并不是只读的，因为变量的值可以随时被修改。

    数据段更进一步细化为**只读数据区**和**读写数据区**。例如，对于一个全聚德字符串定义如下```char s[] = "hello world"```，此变量被存储在可读写区域。然而对于一个常量，如```const char* str = "hello world"```，此字符串被存储在只读数据区

3. BSS段
    
    BSS（Block Started by Symbol）段中的数据在程序开始执行之前被内核算数初始化为0。BSS段中包含所有的**未初始化的全局变量和静态变量**。例如，一个静态变量```static int i```和全局变量```int j```，将被包含在BSS段中。

4. 栈段
    
    由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。

5. 堆区

    用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要大很多。

更多详细信息见：[Memroy layout of C progam](https://www.geeksforgeeks.org/memory-layout-of-c-program/)

### 二. 内存池
内存池（Memory Pool）是一种内存分配方式。通常我们习惯直接使用new、malloc等申请内存，这样做的缺点在于：由于所申请的内存块的大小不确定，当频繁使用时会造成大量的内存碎片并降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。

**《STL源码剖析》中的内存池实现机制：**

**allocate 包装malloc，deallocate 包装free**

一般是一次20*2个申请，先用一办，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小。

1. 首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）
2. 客户端之后有有内存需求，想申请（20\*64bytes）的空间，这时内存池只有（20\*32bytes），就先将（10*64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也.
3. 接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。
4. 如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常

allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。

内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，说白了就是和直接使用new运算符的效果是一样的。

更多参考：[什么是内存池，如何实现？](https://github.com/forthespada/InterviewGuide/blob/main/Doc/Knowledge/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md#3%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B1%A0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0)

### 三、如何让类只在栈（堆）上分配空间
在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr = new A；这两种方式是有区别的：
+ 建立静态类对象：是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。
+ 动态建立类对象：使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行```operator new()```函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。

#### 3.1 只能在对象分配类对象

容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用```new```运算符来建立对象。然而，前面已经说过，```new```运算符的执行过程分为两步，C++提供```new```运算符的重载，其实是只允许重载```operator new()```函数，而```operator new()```函数只用于分配内存，无法提供构造功能。因此，这种方法不可以。

编译器在为类的对象分配空间栈时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会检查。如果**类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存**。

因此将析构函数设为私有的，类对象就无法建立在栈上了，代码如下：
```cpp
class A {  
public:  
    A(){}  
    void destory(){
        delete this;
    }  
private:  
    ~A(){}  
};  
```

试着使用```A a```;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用```new```操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个```destory```函数，来进行内存空间的释放。类对象使用完成后，必须调用```destory```函数。

#### 3.2 只能在栈上分配类对象
只有使用```new```运算符，对象才会建立在堆上，因此，只要禁用```new```运算符就可以实现类对象只能建立在栈上。
	
虽然不能影响```new operator```的能力，但是可以利用一个事实：```new``` operator总是先调用```operator new```，而后者我们是可以自行声明重写。
	
因此，将```operator new()```设为私有即可禁止对象被new在堆上，代码如下：
```cpp
class A {  
private:  
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr){} // 重载了new就需要重载delete  
public:  
    A(){}  
    ~A(){}  
};  

```

参考：[如何让类对象只在栈（堆）上分配空间](https://segmentfault.com/a/1190000009023942)
