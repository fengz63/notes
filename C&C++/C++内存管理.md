### 1. C/CPP程序内存结构

一个典型的C程序内存结构包括一下部分：
+ Text segment（代码段）
+ Initialized data segment（初始化数据段）
+ Uninitialized data segment（未初始化数据段，BSS段）
+ Heap（堆区）
+ STack（栈区）

示意图如下所示：

![](https://raw.githubusercontent.com/fengz63/picture/main/memoryLayoutC.jpg)

+ 1. 代码段
    代码段包括可执行指令。作为内存中的一个区域，代码段在内存中位于堆或者栈下方，防止堆栈溢出时覆盖掉其内容。

        通常代码段是只读的，以防止程序意外地修改其指令。

+ 2. 已初始化数据段
    数据段是程序虚拟地址空间的一部分，它包含已经**初始化的全局变量和静态变量**。数据段并不是只读的，因为变量的值可以随时被修改。

        数据段更进一步细化为**只读数据区**和**读写数据区**。例如，对于一个全聚德字符串定义如下```char s[] = "hello world"```，此变量被存储在可读写区域。然而对于一个常量，如```const char* str = "hello world"```，此字符串被存储在只读数据区

+ 3. BSS段
    BSS（Block Started by Symbol）段中的数据在程序开始执行之前被内核算数初始化为0。BSS段中包含所有的**未初始化的全局变量和静态变量**。例如，一个静态变量```static int i```和全局变量```int j```，将被包含在BSS段中。

+ 4. 栈段
    由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。

+ 5. 堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结
    构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要大很多。

更多详细信息见：[Memroy layout of C progam](https://www.geeksforgeeks.org/memory-layout-of-c-program/)

### 2. 内存池
内存池（Memory Pool）是一种内存分配方式。通常我们习惯直接使用new、malloc等申请内存，这样做的缺点在于：由于所申请的内存块的大小不确定，当频繁使用时会造成大量的内存碎片并降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。

**《STL源码剖析》中的内存池实现机制：**

**allocate 包装malloc，deallocate 包装free**

一般是一次20*2个申请，先用一办，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小。

1. 首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）
2. 客户端之后有有内存需求，想申请（20\*64bytes）的空间，这时内存池只有（20\*32bytes），就先将（10*64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也.
3. 接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。
4. 如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常

allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。

内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，说白了就是和直接使用new运算符的效果是一样的。

更多参考：[什么是内存池，如何实现？](https://github.com/forthespada/InterviewGuide/blob/main/Doc/Knowledge/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md#3%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B1%A0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0)

