### 一、定义

栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。

单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。

听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。本文用讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略。

**单调栈模板**

首先，看一下一个简单的例题：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。

函数签名如下：

vector<int> nextGreaterElement(vector<int>& nums);
比如说，输入一个数组 nums = [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。

解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。

这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 O(n^2)。

这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。

这个情景很好理解吧？带着这个抽象的情景，先来看下代码。
```c++
vector<int> nextGreaterElement(vector<int>& nums) {
    vector<int> res(nums.size()); // 存放答案的数组
    stack<int> s;
    // 倒着往栈里放
    for (int i = nums.size() - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.empty() && s.top() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的 next great number
        res[i] = s.empty() ? -1 : s.top();
        // 
        s.push(nums[i]);
    }
    return res;
}
```
这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。

这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂度只有 O(n)。

分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。

**单调栈变形**
力扣第962题：[962.最大宽度坡](https://leetcode-cn.com/problems/maximum-width-ramp/)

首先正序遍历数组 A，将以 A[0] 开始的递减序列的元素下标依次存入栈中。
```
为什么要存从 A[0] 开始的递减序列呢？
因为题中条件 A[i] <= A[j]，所以要让 A[i] 的值尽可能的小，即从 A[0] 开始的一个递减序列。单调栈中记录的是从后往前每个大分段 “坡底” 所在的位置。
```
以 [6, 1, 8, 2, 0, 5] 为例，由于 (6, 1, 0) 是递减的，所以栈中存的元素应该为：((4, 1, 0)，其中4为栈顶，0为栈底)。

其中 [2, 0, 5] 也是一个满足条件的坡并且宽度为 2，但是为什么在计算的时候没有算它呢？
因为该数组从 A[0] 开始的递减序列为 (6, 1, 0) 并没有元素 2，是因为在元素 2 的左边有比它还要小的元素 1。当计算最大宽度坡时 1 和 2 相比，不管是元素值还是元素的下标都更小，所以若以 2 为坡底能计算出某一坡的宽度时同样的以 1 为坡底也能计算出相应的坡的宽度并且宽度更大，所以就不需要计算以 2 为坡底的坡的宽度了。

此时栈 stack：(4(0), 1(1), 0(6))：然后逆序遍历数组 A，若以栈顶元素为下标的元素值 A[stack.top()] 小于等于当前遍历的元素 A[i]，即 A[stack.top()] <= A[i]。此时就是一个满足条件的坡的宽度，并且这个宽度一定是栈顶这个坡底 i 能形成的最大宽度，将栈顶元素出栈并计算当前坡的宽度，保留最大值即可。代码如下：
```c++
class Solution {
public:
    int maxWidthRamp(vector<int>& nums) {
        ios::sync_with_stdio(false);
        int n = nums.size();
        stack<int> st;
        int ans = INT16_MIN;
        for(int i = 0; i < n; ++i)
        {
            if(st.empty() || nums[st.top()] > nums[i])
            {
                st.push(i);
            }
        }
        for(int i = n-1; i >= 0; --i)
        {
            while(!st.empty() && nums[st.top()] <= nums[i])
            {
                int pos = st.top();
                st.pop();
                ans = max(ans, i - pos);
            }
            st.push(i);
        }
        return ans;
    }
};
```
最后返回最大宽坡度即可。