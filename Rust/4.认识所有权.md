### 一、什么是所有权

#### 1.1. 内存分配
对于```String```来说，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：
+ 必须在运行时向操作系统请求内存
+ 需要一个当我们处理完```String```时将内存返回给操作系统的办法

第一部分由我们完成：当调用```String::from```时，他的实现请求其所需要的内存。

第二部分实现起来就各有区别了。在有 **垃圾回收（garbage collector， GC）** 的语言中， GC 记录并清除不再使用的内存，而我们并不需要关心它。没有 GC 的话，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 allocate 配对一个 free。对于 rust 来说：内存在拥有它的变量离开作用域后就被自动释放。

#### 1.2. 变量与数据交互的方式（-）：移动
rust语言中 = 的拷贝（以String为例），只拷贝指针、长度和容量，而不拷贝数据，这个操作被称为**移动（move）**。例如：
```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```
上述例子会发生错误，因为s1拷贝之后失去所有权，因此会被系统自动回收。

这里隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 **自动** 的复制可以被认为对运行时性能影响较小。

#### 1.3. 变量与数据交互的方式（二）：克隆
如果我们 确实 需要深度复制 ```String``` 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 ```clone``` 的通用函数。
这种方式得到的拷贝不仅仅拷贝了栈上（指向string类型数据的指针信息）的数据，同时把堆上存储的数据也拷贝了。

**只在栈上的数据：拷贝**

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

上述例子可以正常输出结果，似乎与前面讲到的有所冲突。原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 ```y``` 后使 ```x``` 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 ```clone``` 并不会与通常的浅拷贝有什么不同，我们可以不用管它。

Rust有一个```Copy``` trait的特殊注解，可以用在类似整形这样的存储在栈上的类型上。如果一个类型拥有 ```Copy``` trait，一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 ```Drop``` trait 的类型使用 ```Copy``` trait。如果我们对其值离开作用域时需要特殊处理的类型使用 ```Copy``` 注解，将会出现一个编译时错误。要学习如何为你的类型增加 Copy 注解，请阅读 [“可派生的 trait”](https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html)。

那么什么类型是 Copy 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则，任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的。如下是一些 Copy 的类型：
+ 所有整数类型，比如 ```u32```。
+ 布尔类型， ```bool```，它的值是 ```true``` 和 ```false```。
+ 所有浮点数类型，比如 ```f64```。
+ 字符类型， ```char```。
+ 元组，当且仅当其包含的类型也都是 Copy 的时候。比如，```(i32, i32)``` 是 Copy 的，但 ```(i32, String)``` 就不是。

详见：[什么是所有权](https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html)

### 二、引用与借用
详见：[引用与借用](https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html)

### 三、Slice
另一个没有所有权的数据类型是 slice。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。

**字符串slice：**

字符串 slice（string slice）是 ```String``` 中一部分值的引用，它看起来像这样：
```rust
fn main() {
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
}
```
这类似于引用整个 String 不过带有额外的 [0..5] 部分。它不是对整个 String 的引用，而是对部分 String 的引用。

**字符串字面值就是 slice**

```rust
let s = "Hello world!";
```
这里 ```s``` 的类型是 ```&str```：它是一个指向二进制程序特定位置的slice。这也就是为什么字符串字面值是不可变的； ```&str``` 是一个不可变引用。

其他详见：[Slices](https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html)