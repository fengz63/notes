### 一、泛型数据类型
使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型。

**在函数定义中使用泛型**

当使用泛型定义函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。采用这种技术，使得代码适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。一个示例如下所示：
```rust
fn largeet<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }
    largest
}
```
上述是一个在函数体中定义泛型的例子，如上述所示（此代码目前还无法运行），如果要在函数体中使用参数，就必须在函数签名中声明它的名字，好让编译器知道这个名字指代的是什么。同理，当在函数签名中使用一个类型参数时，必须在使用它之前就声明它。为了定义泛型版本的 largest 函数，类型参数声明位于函数名称与参数列表中间的尖括号 ```<>``` 中，像这样：
```rust
fn largest<T>(list: &[T]) -> T {}
```
可以这样理解这个定义：函数```largest```有泛型类型```T```，它有个参数```list```，其类型是元素为```T```的slice。```largest```函数的返回值也是```T```。

**结构体定义中的泛型**

同样也可以用 ```<>```语法来定义结构体，它包含一个或多个泛型参数类型字段。示例如下：
```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```
注意 ```Point<T>``` 的定义中只使用了一个泛型类型，这个定义表明结构体 ```Point<T>``` 对于一些类型 ```T``` 是泛型的，而且字段 x 和 y 都是 相同类型的，无论它具体是何类型。

更多请参考：[泛型数据类型](https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html)

### 二、trait：定义共享的行为

*trait* 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。

`
注意：trait 类似于其他语言中的常被称为 接口（interfaces）的功能，虽然有一些不同。
`

**定义trait**

一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。

我们想要创建一个多媒体聚合库用来显示可能储存在 NewsArticle 或 Tweet 实例中的数据的总结。每一个结构体都需要的行为是他们是能够被总结的，这样的话就可以调用实例的 summarize 方法来请求总结。如下示例所示：
```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```
这里使用```trait```关键字来声明一个```trait```，后面是```trait```的名字，在这个例子中是```Summary```。在大括号中声明描述实现这个 ```trait``` 的类型所需要的行为的方法签名，在这个例子中是 ```fn summarize(&self) -> String```。

在方法签名后跟分号，而不是在大括号中提供其实现。接着每一个实现这个 ```trait``` 的类型都需要提供其自定义行为的方法体，编译器也会确保任何实现 ```Summary``` trait 的类型都拥有与这个签名的定义完全一致的 ```summarize``` 方法。

trait体中可以有多个方法：一行一个方法签名且都以分号结尾。

相关例子见：[实现trait](https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html)

三、生命周期与引用有效性

Rust中每一个引用都有其 **生命周期（lifetime）**，也就是引用保持有效的作用域。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。

**生命周期注解语法**

生命周期注解并不改变任何的生命周期的长短。生命周期注解有一个不太常见的语法：生命周期参数名称必须以撇号（```'```）开头，其名称通常全是小写，类似于泛型，其名称非常短。```'a``` 是大多数人默认使用的名称。生命周期参数注解位于引用的 ```&``` 之后，并有一个空格来将引用类型与生命周期注解分隔开。示例如下：
```rust
&i32            // 引用
&'a i32         // 带有显式生命周期的引用
&'a mut i32     // 带有显式生命周期的可变引用
```

被编码进 Rust 引用分析的模式被称为 **生命周期省略规则（lifetime elision rules）**。这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。

函数或方法的参数的生命周期被称为 **输入生命周期（input lifetime）**，而返回值的生命周期被称为 **输出生命周期（output lifetime）**。

编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 fn 定义，以及 impl 块。

第一条规则：每一个是引用的参数都有它自己的生命周期。换句话说就是，有一个引用参数的函数有一个生命周期参数：```fn foo<'a>(x: &'a i32)```，有两个引用参数的函数有两个不同的生命周期参数，```fn foo<'a, 'b>(x: &'a i32, y: &'b i32)```，以此类推。

第二条规则：如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：```fn foo<'a>(x: &'a i32) -> &'a i32```。

第三条规则：如果方法有多个输入生命周期参数并且其中一个参数是 &self 或 &mut self，说明是个对象的方法(method)(注： 这里涉及rust的面向对象参见17章), 那么所有输出生命周期参数被赋予 self 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。

**静态生命周期**

这里有一种特殊的生命周期：```'static```，其生命周期能够存活于整个程序期间。所有的字符串字面值都拥有```'static```生命周期，我们也可以选择下面这样标注出来。
```rust
let s: &'static str = "I have a static lifetime.";
```
