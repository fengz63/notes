### 一、变量和可变性
变量默认是不可改变的（immutable）。这是推动你以充分利用 Rust 提供的安全性和简单并发性来编写代码的众多方式之一。不过，你仍然可以使用可变变量。让我们探讨一下 Rust 为何及如何鼓励你利用不可变性，以及何时你会选择不使用不可变性。

rust编译器保证如果声明一个值不可变，它就真的不会变。这意味着阅读和编写代码时，不需要追踪一个值如何和在哪里可能会变，从而使得代码易于推导。

不过可变性也是非常有用的。变量只是默认不可变；你可以在变量名之前加 ```mut``` 来使其可变。除了允许改变值之外，```mut``` 向读者表明了其他代码将会改变这个变量值的意图。

**常量和变量的区别：**

不允许改变值的变量，可能会使你想起另一个大部分编程语言都有的概念：**常量（constants）**。类似于不可变变量，常量是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。

首先，不允许对常量使用 ```mut```。常量不光默认不能变，它总是不能变。

声明常量使用 ```const``` 关键字而不是 ```let```，并且 *必须* 注明值的类型。

常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。

最后一个区别是，常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。

这是一个声明常量的例子，它的名称是 MAX_POINTS，值是 100,000。（Rust 常量的命名规范是使用下划线分隔的大写字母单词，并且可以在数字字面值中插入下划线来提升可读性）：

```rust
const MAX_POINTS: u32 = 100_000;
```

### 二、数据类型
在 Rust 中，每一个值都属于某一个 **数据类型（data type）**，这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。

记住，Rust 是 **静态类型（statically typed）**语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。

### 三、函数
函数遍布于 Rust 代码中。你已经见过语言中最重要的函数之一：```main``` 函数，它是很多程序的入口点。你也见过 ```fn``` 关键字，它用来声明新函数。

**函数参数**
函数也可以被定义为拥有 **参数（parameters）**，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（arguments），但是在日常交流中，人们倾向于不区分使用 parameter 和 argument 来表示函数定义中的变量或调用函数时传入的具体值。
```rust
fn main() {
    another_function(5);
}
fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}
```

在函数签名中，**必须** 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器不需要你在代码的其他地方注明类型来指出你的意图。

**具有返回值的函数**

函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头（->）后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 return 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。这是一个有返回值的函数的例子：
```rust
fn five() -> i32 {
    5
}
fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```