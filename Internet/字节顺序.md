#### 1. 字节顺序
字节顺序又称为端绪或者尾序，指电脑内存中或在数字通信链路中，组成**多字节的字**的**字节**的排列顺序。

在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节的排列方式有两个通用规则。例如：将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称为小端序；反正称为大端序。

**在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化**

例如一个变量x的类型为int，位于地址```0x100```处，它的值为```0x01234567```，地址范围为```0x100~0x103```字节，其内部排列顺序依赖于机器的类型。大端序从首位开始将是：```0x100: 0x01, 0x101: 23, ...```。而小端序将是：```0x100: 0x67, 0x101: 45, ...```。

#### 1.1 大端序
数据的高位字节存放在地址的低端 低位字节存放在地址高端，如下图所示：

![](https://raw.githubusercontent.com/fengz63/picture/main/20210831093833.png)

#### 1.2 小端序
数据的高位字节存放在地址的高端 低位字节存放在地址低端，如下图所示：

![](https://raw.githubusercontent.com/fengz63/picture/main/20210831094237.png)

#### 1.3 网络序
网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。

Berkeley套接字定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl，htons用于本机序转换到网络序；ntohl，ntohs用于网络序转换到本机序。

**编程判断大端序和小端序：**
```cpp
#include <iostream>
#include <vector>

using namespace std;

union data
{
    unsigned short a;
    char c;
};

int main()
{
    data d;
    d.a = 0x0123;
    if(d.c == 0x01)
    {
        cout << "Big Endian" << endl;
    }
    else if(d.c == 0x23)
    {
        cout << "Little Endian" << endl;
    }
    return 0;
}
```

data中的c对应整个data的低地址段，若这一段内容等于0x23，即等于整数0x0123中的低位字节，说明低位字节先存储，说明是小端序。反之若c=0x01说明高位字节先存储，说明是大端序。
