### 一、逻辑地址与物理地址
1. 逻辑地址：
    又称为虚拟地址，**也就是在程序编译时将目标模块从0开始编址**，装入内存之后再转换成物理地址，从0开始编址的地址就称为逻辑地址。例如C语言中取地址操作符（&）就是求的逻辑地址。

2. 物理地址：
    又称为绝对地址，**是加载到内存单元中的真正物理地址**。

    一般来说，从逻辑地址到物理地址有两种方式：分页和分段。操作系统根据映射表，将逻辑地址转换为物理地址。

### 二、虚拟内存
#### 2.1 为什么需要虚拟内存？
为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了**虚拟内存**。

虚拟内存技术使得不同进程在运行过程中，他所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。

事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据，还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

#### 2.2 虚拟内存的优点：
1. 扩大地址空间；
2. 内存保护：内存保护：每个进程运行在各自的寻你内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。
3. 公平内存分配。采用了虚存以后，每个进程都相当于由同样大小的虚存空间。
4. 当进程通信时，可采用虚存共享的方式实现。
5. 当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射进去就可以了，节省内存
6. 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中，当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高
7. 程序需要分配连续内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。


### 三、分段系统
程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。

分段机制下的虚拟地址由两部分组成，**段选择子**和**段内偏移量**。
+ 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。
+ 虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：
+ 内存碎片问题
+ 内存交换的效率低

具体见：[linux内存管理](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485033&idx=1&sn=bf9ba7aca126ad186922c57a96928593&chksm=f98e42c3cef9cbd514df38d04deb5e7a9ea67dbd478da75fc4a7636ee90b1384d65f68eb23f5&scene=158#rd)
### 四、分页系统
分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。

要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（page）。在linux下，每一页的大小为 4KB。

**分页大小的影响：**

+ 过小的页面大小会带来较大的页表项，增加寻址时TLB的查找时间和额外开销；
+ 过大的页面大小会浪费内存空间，造成内存碎片，降低内存的利用率。

虚拟地址与物理地址之间通过页表来映射，如下图所示：

![](https://raw.githubusercontent.com/fengz63/picture/main/20210807161249.jpg)

页表实际上存储在 CPU 的内存管理单元（MMU）中，于是 CPU 可以直接通过 MMU 找出实际要访问的物理内存地址。

页表是一种特殊的数据结构，存放逻辑页与物理页帧的对应关系。每个进程都拥有一个自己的页表，PCB中有指针指向页表。页表的主要作用是实现从页号到物理块号的地址映射。

由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。

**分页机制下，虚拟地址和物理地址是如何映射的？**

在分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。

总结一下，对于一个内存地址转换，包括以下三个步骤：
+ 把虚拟内存地址切分成页号和页内偏移量；
+ 根据页号，从页表里面，查询对应的物理页号；
+ 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

**简单的分页有什么缺陷？**

由空间上的缺陷。

因为操作系统是可以同时运行非常多的进程的，这意味着页表会非常的庞大。在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。

如果系统中有100个进程的话，就需要400MB的内存来存储页表，这是非常大的内存了。64位的环境会更大。

更多详见：[linux内存管理](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485033&idx=1&sn=bf9ba7aca126ad186922c57a96928593&chksm=f98e42c3cef9cbd514df38d04deb5e7a9ea67dbd478da75fc4a7636ee90b1384d65f68eb23f5&scene=158#rd)

#### 4.1 缺页中断
当CPU访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。它与一般终端的主要区别在于：
+ 缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。
+ 缺页中断返回到该指令的开始重新执行「该指令」，而一般的中断返回到该指令的「下一个指令」执行。

缺页中断的处理流程如下所示：

![](https://raw.githubusercontent.com/fengz63/picture/main/202108201010.png)

1. 在CPU里访问一下Load M指令，然后CPU会去找 M 所对应的页表项。
2. 如果该页表项的状态位是「有效的」，那CPU就可以直接去访问物理内存，如果状态位是「无效的」，则CPU会发送缺页中断请求。
3. 操作系统如果收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。
4. 找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。若找不到空闲页，就说明此时内存已满，这时候需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。
5. 页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」
6. 最后CPU重新执行导致缺页异常的命令。

更多参考：[调度算法](https://www.cnblogs.com/xiaolincoding/p/13631224.html)