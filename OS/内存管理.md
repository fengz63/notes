### 一、逻辑地址与物理地址
1. 逻辑地址：
    又称为虚拟地址，**也就是在程序编译时将目标模块从0开始编址**，装入内存之后再转换成物理地址，从0开始编址的地址就称为逻辑地址。例如C语言中取地址操作符（&）就是求的逻辑地址。

2. 物理地址：
    又称为绝对地址，**是加载到内存单元中的真正物理地址**。

    一般来说，从逻辑地址到物理地址有两种方式：分页和分段。操作系统根据映射表，将逻辑地址转换为物理地址。

### 二、虚拟内存
#### 2.1 为什么需要虚拟内存？
为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了**虚拟内存**。

虚拟内存技术使得不同进程在运行过程中，他所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。

事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据，还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

#### 2.2 虚拟内存的优点：
1. 扩大地址空间；
2. 内存保护：内存保护：每个进程运行在各自的寻你内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。
3. 公平内存分配。采用了虚存以后，每个进程都相当于由同样大小的虚存空间。
4. 当进程通信时，可采用虚存共享的方式实现。
5. 当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射进去就可以了，节省内存
6. 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中，当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高
7. 程序需要分配连续内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。


### 三、分段系统
程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。

分段机制下的虚拟地址由两部分组成，**段选择子**和**段内偏移量**。
+ 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。
+ 虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：
+ 内存碎片问题
+ 内存交换的效率低

具体见：[linux内存管理](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485033&idx=1&sn=bf9ba7aca126ad186922c57a96928593&chksm=f98e42c3cef9cbd514df38d04deb5e7a9ea67dbd478da75fc4a7636ee90b1384d65f68eb23f5&scene=158#rd)
### 四、分页系统
分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。

要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（page）。在linux下，每一页的大小为 4KB。

虚拟地址与物理地址之间通过页表来映射，如下图所示：

![](https://raw.githubusercontent.com/fengz63/picture/main/20210807161249.jpg)

也表实际上存储在 CPU 的内存管理单元（MMU）中，于是 CPU 可以直接通过 MMU 找出实际要访问的物理内存地址。

由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。

**分页机制下，虚拟地址和物理地址是如何映射的？**

在分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。

总结一下，对于一个内存地址转换，包括以下三个步骤：
+ 把虚拟内存地址切分成页号和页内偏移量；
+ 根据页号，从页表里面，查询对应的物理页号；
+ 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

更多详见：[linux内存管理](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485033&idx=1&sn=bf9ba7aca126ad186922c57a96928593&chksm=f98e42c3cef9cbd514df38d04deb5e7a9ea67dbd478da75fc4a7636ee90b1384d65f68eb23f5&scene=158#rd)