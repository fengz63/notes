### 一、几种典型的锁
#### 1.1 读写锁
读写锁（Read Write Lock）是一种特殊的互斥锁。
+ 多个读者可以同时进行读
+ 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
+ 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

#### 1.2 互斥锁（mutex）
+ 互斥锁是linux内核中用于互斥操作的一种同步原语。互斥锁每次只允许一个进程进入临界区，有点类似于二值信号量。

互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度。

为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。

互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过```pthread_mutex_lock```操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时**会通过上下文切换将线程A置于等待队列中**，此时core 0就可以运行其他的任务（如线程C）。

互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右。实际上互斥锁在锁被持有时选择 自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁。互斥锁的缺点是互斥锁对象的结构较大，会占用更多的CPU缓存和内存空间。

互斥锁的数据结构如下所示：
```cpp
struct mutex {
	atomic_long_t		owner;           //原子计数，用于指向锁持有者的task struct结构
	spinlock_t		wait_lock;           //自旋锁，用于wait_list链表的保护操作
#ifdef CONFIG_MUTEX_SPIN_ON_OWNER
	struct optimistic_spin_queue osq; /* Spinner MCS lock */        //optimistic spinning锁
#endif
	struct list_head	wait_list;       //链表，用于管理所有在该互斥锁上睡眠的进程
#ifdef CONFIG_DEBUG_MUTEXES
	void			*magic;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map	dep_map;
#endif
};
```

mutex lock为了提高性能，分为三种路径处理，优先使用宽度和中速路径，如果条件不满足则会跳转到慢速路径来处理：
+ 快速路径：在```_mutex_trylock_fast```中实现的，该函数的实现也很简单，直接调用```atomic_long_cmpxchg_release(&lock->owner, 0UL, curr)```函数来进行判断，如果```lock->owner == 0```表明锁未被持有，将curr赋值给lock->owner标识，curr进程持有该锁，并直接返回；```lock->owner```不等于0，表明锁被持有，需要进入下一个路径来处理。

+ 中速路径：是在```__mutex_lock_common```中实现。当发现mutex锁的持有者正在运行（另一个CPU）时，可以不进行睡眠调度，而可以选择自旋等待，当锁持有者正在运行时，它很有可能很快会释放锁，这个就是乐观自旋的原因；

+ 慢速路径：是在```__mutex_lock_common```中实现，当没有获取到锁时，会调用```schedule_preempt_disabled```将本身的任务进行切换出去，睡眠等待，这也是它慢的原因了；

更多见：[Linux Mutex机制分析](https://www.cnblogs.com/LoyenWang/p/12826811.html)

#### 1.3 自旋锁
+ 自旋锁属于busy-waiting类型的锁。如果线程A是使用```pthread_spin_lock```操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。

+ 如果别的线程长时间占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。

Linux中spinlock机制发展到现在，其实现方式大致有3种：
1. 经典的CAS（Compare And Swap）：

    spinlock用一个整形变量表示，其初始值为1，表示available的状态。当一个CPU（设为CPU A）获得spinlock后，会将该变量的值设为0，之后其他CPU试图获取这个spinlock时，会一直等待，直到CPU A释放spinlock，并将该变量的值设为1。

    存在的问题：
    + 基于CAS的实现速度很快，尤其是在没有真正竞态的情况下（事实上大部分时候就是这种情况）， 但这种方法存在一个缺点：它是「不公平」的。 一旦spinlock被释放，第一个能够成功执行CAS操作的CPU将成为新的owner，没有办法确保在该spinlock上等待时间最长的那个CPU优先获得锁，这将带来延迟不能确定的问题。

2. Ticket Spinlock

    为了解决这种「无序竞争」带来的不公平问题，spinlock的另一种实现方法是采用排队形式的"ticket spinlock"。

3. MCS Lock

具体参考：

[Linux中的spinlock(一)](https://zhuanlan.zhihu.com/p/80727111)

[Linux中的spinlock(二)](https://zhuanlan.zhihu.com/p/89058726)

虽然自旋锁效率比较高，但是也存在许多缺点：
+ 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。
+ 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。

#### 1.4 条件变量
互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。

#### 1.5 StampedLock
高并发情况下，读写锁很容易出现线程饥饿问题，即多个线程持有读锁时，此时线程很难获取到写锁。

1. 特性：三种数据访问模式：

    + Writing（独占写锁）：writeLock方法会使线程阻塞等待独占访问，可类比读写锁的写锁模式，同一时刻有且只有一个写线程获取锁资源；
    + Reading（悲观读锁）：readLock方法，允许多个线程同时获取悲观读锁，悲观读锁于独占写锁互斥，与乐观读共享。
    + OptimisticReading（乐观锁）：是乐观读，并没有加锁。仅当当前未处于 Writing 模式 tryOptimisticRead 才会返回非 0 的邮戳（Stamp），如果在获取乐观读之后没有出现写模式线程获取锁，则在方法validate返回 true ，允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。

    *注意事项：*
        
    + StampedLock是不可重入锁，如果当前线程已经获取了写锁，再次重复获取的话就会死锁；
    + StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。


2. 乐观读带来的性能提升：

    **StampedLock 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。**

    然而，同时允许多个乐观读和一个先线程同时进入临界资源操作，那读取的数据可能是错的怎么办？

    乐观读不能保证读取到的数据是最新的，所以将数据读取到局部变量的时候需要通过```lock.validate(stamp)```检验下是否被写线程修改过，若是修改过则需要上悲观读锁，再重新读取数据到局部变量。

    同时由于乐观读并不是锁，所以没有线程唤醒与阻塞导致的上下文切换，性能更好。

3. 使用场景和注意事项：

    对于读多写少的并发场景，StampedLock 的性能很好，通过乐观度模式很好的解决了写线程“饥饿”的问题，我们可以使用StampedLock 来代替ReadWriteLock，但是需要注意的是 StampedLock 的功能仅仅是ReadWriteLock的子集，在使用的时候，有以下几个地方需要注意一下：
    + StampedLock时不可重入锁，使用过程中一定要注意；
    + 悲观锁、写锁都不支持条件变量Condition，当需要这个特性的时候需要注意。
    + 如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。所以，使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()。这个规则一定要记清楚。

更多参考：[高性能解决线程饥饿利器 StampedLock](https://segmentfault.com/a/1190000024540229)

### 二、死锁
**死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去**。

#### 2.1 死锁产生的条件：
1. 互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。
2. 不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。
3. 请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。
4. 循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

#### 2.2 死锁预防
在程序运行之前预防发生死锁。

1. 破坏互斥条件

    例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。
2. 破坏请求和保持条件

    一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。
3. 破坏不剥夺条件

    允许抢占资源
4. 破坏循环请求等待

    给资源统一编号，进程只能按编号顺序来请求资源。

#### 2.3 死锁恢复
1. 利用抢占恢复
2. 死用回滚恢复
3. 通过杀死进程恢复