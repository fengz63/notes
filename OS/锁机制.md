### 一、几种典型的锁
#### 1.1 读写锁
读写锁（Read Write Lock）是一种特殊的互斥锁。
+ 多个读者可以同时进行读
+ 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
+ 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

#### 1.2 互斥锁（mutex）
一次只能一个线程拥有互斥锁，其他线程只有等待

互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度。

为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。

互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过```pthread_mutex_lock```操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时**会通过上下文切换将线程A置于等待队列中**，此时core 0就可以运行其他的任务（如线程C）。

互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁

#### 1.3 自旋锁
如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获得位置。如果别的线程长时间占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。

自旋锁属于busy-waiting类型的锁。如果线程A是使用```pthread_spin_lock```操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。

虽然自旋锁效率比较高，但是也存在许多缺点：
+ 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。
+ 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。

#### 1.4 条件变量
互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。

### 二、死锁
**死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去**。

#### 2.1 死锁产生的条件：
1. 互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。
2. 不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。
3. 请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。
4. 循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

#### 2.2 死锁预防
在程序运行之前预防发生死锁。

1. 破坏互斥条件

    例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。
2. 破坏请求和保持条件

    一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。
3. 破坏不剥夺条件

    允许抢占资源
4. 破坏循环请求等待

    给资源统一编号，进程只能按编号顺序来请求资源。

#### 2.3 死锁恢复
1. 利用抢占恢复
2. 死用回滚恢复
3. 通过杀死进程恢复