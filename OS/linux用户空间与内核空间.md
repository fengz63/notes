### 一、用户空间与内核空间
#### 1.1. 系统调用
Linux系统中，有一组用于实现系统功能的子程序，称为系统调用。

这些系统调用并不直接对用户的应用程序提供接口，而是通过C语言函数库，进行了一些封装和扩展，例如文件操作的```open, read, write```；socket操作的```bind, accept, send```等。

#### 1.2. 内核空间、用户空间
现代操作系统一般都将运行空间划分为两个，用户空间和内核空间。不同的空间拥有自己的内存地址范围，在32位操作系统中，一般将对高的1G字节划分为内核空间，供内核使用，而将较低的3G空间划分为用户空间，供各个进程使用。

其中：
+ 内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。
+ 进程在运行的时候，在内核空间和用户空间各有一个堆栈。
+ 用户空间中，每个进程的用户空间是互相独立的，互不相干。
+ 内核空间中，绝大部分是共享的，并不是完全共享，因为内核空间中，不同进程的内核栈之间是不共享的。

#### 1.3. 内核态、用户态
应用程序如果运行在用户空间，就叫用户态；如果运行在内核空间，就叫内核态。
+ 用户态的进程不能随意操作内核地址空间：底层是利用处理器提供的技术，例如Intel X86架构使用了4个级别来标明不同的特权级权限。Linux使用了其中的r0和r3，r0位内核态，r3为用户态。
+ 运行在用户空间时，进程使用的是用户空间中的堆栈；而运行在内核空间时，进程使用的是内核空间中的堆栈。

#### 运行态切换
切换有三种触发方式，这里主要针对系统调用这种方式，这里不涉及运行态切换的细节。

用户态的进程是不能访问内核所占用的内存空间，也不能直接调用内核函数的，因此要进行系统调用的时候，就要将进程切换到内核态中去。

切换的时候，会先保护运行上下文，设置要调用的相关信息，然后利用0x80中断，然后进入内核态进行系统调用。

**例子**：

服务端读取一个文件内容，然后发送给用户，大致的过程如下所示：

*需要重点关注的是，数据从I/O设备中取出后，会先存放在内核buf中，系统调用完成之后，会将数据从内核buf拷贝到用户空间的buf。*

![](https://raw.githubusercontent.com/fengz63/picture/main/20210813140340.jpg)

### 二、零拷贝
上文中最后的一个例子指出数据会经过2次用户空间与内核空间之间的拷贝：
+ 内核读取文件数据后，从内核空间拷贝到用户空间
+ 调用socket的write时，将数据从用户空间拷贝到内核空间。

其中还涉及到四次上下文切换：
+ 调用read读取文件时，从用户态切换到内核态
+ 读取完成之后，切换回来
+ 调用write发送数据时，从用户态切换到内核态
+ 发送完之后，切换回来

如果只需要实现一个简单的，不需要考虑高性能的业务，那么到这一步基本上就完成了，但是如果做的是一个有一定性能要求的框架，比如Netty，Kafka，MQ等等，那么这里还是有优化空间的，优化点就在于本文要介绍的zero-copy（零拷贝）技术。

DMA（Direct Memory Access）：直接存储器访问。DMA是一种无需CPU的参与，让外设和系统内存之间进行双向数据传输的硬件机制。使用DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而大大提高系统的吞吐率。

零拷贝技术：就是避免将数据从一块存储拷贝到另一块存储的技术，从而节省拷贝带来的CPU开销，零拷贝并不是将拷贝操作完全取消。目前零拷贝技术主要有三种类型：
+ 直接I/O：数据直接跨过内核，在用户地址空间与I/O设备之间传递，内核只是进行必要的虚拟存储配置等辅助工作；
+ 避免内核和用户空间之间的数据拷贝：当应用程序不需要对数据进行访问时，则可以避免将数据从内核空间拷贝到用户空间；
+ copy on write：写时拷贝技术，数据不需要提前拷贝，而是当需要修改的时候再进行部分拷贝。

#### 2.1. 直接I/O
使用直接I/O的方式，可以跨过内核，直接将I/O设备中的数据传递到用户空间中。

一linux中读取文件为例，open函数的原型为：
```cpp
int open(const char *pathname, int oflag, … /*, mode_t mode */ );
```
采用直接I/O时，需要在调用open的时候，传入```O_DIRECT```标识符，让操作系统知道接下来对文件的读写操作使用直接I/O的方式。这种类型的零拷贝多用于数据库系统中，他们更倾向于自己实现一套缓存机制，以更好的提供业务服务。

#### 2.2. 避免内核和用户控件之间的数据拷贝
**mmap**

用户态的进程是不能随意操作内核地址空间的，mmap也没有提供用户进程直接操作内核地址空间的能力，而是通过内存映射的机制，把内核中的部分内存空间映射到用户空间的内存，用户空间和内核空间共享一块相同的物理内存，从而提供用户进程对内存直接访问的能力。

有了mmap的支持，数据从文件中读取到内核空间之后，就不会再拷贝到用户空间，当调用socket的write时，数据会直接从内核缓存中直接拷贝到Socket的缓冲区中，避免了在用户空间中多中转一次。

mmap虽然能减少一次数据拷贝，但是还是需要4次上下文切换：
+ 调用mmap读取文件时，从用户态切换到内核态；
+ 读取完成之后，切换回来；
+ 调用write发送数据时，从用户态切换到内核态；
+ 发送完成之后，切换回来。

更多见：[Linux-Zero-Copy](https://cllc.fun/2020/03/18/linux-zero-copy/)

#### 2.3 Copy-on-Write
写时拷贝技术，也算是一种零拷贝技术，其核心思想是：当有多个调用者都需要请求相同资源时，一开始资源只会有一份，多个调用者共同读取这一份资源，当某个调用者需要修改数据的时候，才会分配一块内存，将数据拷贝过去，供这个调用者使用，而其他调用者依然还是读取最原始的那份数据。每次有调用者需要修改数据时，就会重复一次拷贝流程，供调用者修改使用。

更多参考：

[零拷贝技术](https://www.cnblogs.com/xiaolincoding/p/13719610.html)

[linux零拷贝技术](https://mp.weixin.qq.com/s/1Hi4acZXyer0gnyxUGCDdg)