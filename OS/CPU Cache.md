### 1. cache的作用
随着CPU速度的加快，CPU和内存再速度上的差异日趋显著。随着这些差异的扩大，继续引入一种新型的快速内存来弥补两者的差距。而这种新型的高速内存便是“CPU高速缓存（CPU Cache）”。

CPU cache是CPU用来降低从内存访问数据的平均成本（时间或性能）的硬件高速缓存。它位于存储层次结构体系（类似金字塔模型）中自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但是读写访问速度接近CPU的时钟频率。如下图所示：

![](https://raw.githubusercontent.com/fengz63/picture/main/202108171435.jpg)

根据程序对内存地址访问规律上的局部性（时间局部性和空间局部性）原则，CPU会将最近频繁访问使用或是临近即将使用的指令或数据存储在cache中，以减少CPU下一次获取该指令的时钟周期。

当CPU在访问内存时候，会先去cache中查询所需指令或数据是否已存在，若存在，则不用去访问内存，取而代之的是直接获取并解码执行；若不在高速cache中，则继续向低一层级的内存中去获取该指令，载入高速cache，然后返回给cpu执行。

在操作系统中查询缓存大小和位置的命令如下所示：
```shell
$lscpu | grep cache
L1d cache:             32K
L1i cache:             32K
L2 cache:              256K
L3 cache:              15360K
```
根据上述信息可知，该CPU体系结构中共有3级缓存，对于L1缓存，大小为64K，其中L1d是L1 Cache for Data，即数据缓存，L1i是L1 Cache for Instruction，即指令缓存。L2缓存大小为256K，L3缓存大小为15360K。

#### 1.1 Cache相关术语
1. 缓存命中（Cache Hit）：

    CPU需要数据时，先去L1搜索，若L1未找到，则接着L2、L3缓存中搜索，若找到了所需要的数据，则称为缓存命中。

2. 缓存缺失（Cache Miss）：

    若CPU在高速缓存中没有找到所的数据，则CPU必须请求将其从内存或存储设备（操作系统+虚拟存储器+虚拟内存范畴）加载到缓存，这便是缓存未命中。

3. 命中时间（His Rate）：

    访问某层存储器层次结构所需要的时间，包括了判断当前的访问是命中还是缺失所需要的时间。

4. 缺失代价（Miss Penalty）：

    将相应的数据（内存和cache间的块称为：高速缓存线）从低级存储器复制到高层存储器所需的时间。包括访问块、数据逐层传输、将数据插入发生缺失的层和将信息块传输给请求者的时间。

#### 1.2 Cache和Main Memory的异同
**相同点：**

+ 都是基于半导体和晶体管制造的；
+ Cache和Main Memory都是属于易失性存储器，当电源关闭时丢失其内容；

**不同点：**

+ Cache只保存主存种最常用的信息或程序代码的副本；
+ Cache通常集成在CPU芯片上。主内存（DRAM）放在主板上，并通过内存总线连接到CPU。
+ Cache更靠近CPU，因此读写速度比主存快
+ 主存比Cache大很多倍，而且造价更便宜。通常主存为几个G，而Cache则为几KB或几MB;

### 2. 什么是cache line
Cache Line能够简单的理解为CPU Cache中的最小缓存单位。内存和高速缓存之间或高速缓存之间的数据移动不是以单个字节或word完成的。

相反，移动的最小数据单位称为 **缓存行（Cache Line）**，有时称为缓存块。目前主流的CPU Cache的Cache Line大小都是64Bytes。假设有一个512字节的一级缓存，那么按照64B的缓存单位大小来算，这个一级缓存所能存放的缓存个数就是512/64 = 8个。

查询cache line指令如下所示：
```shell
$cat /sys/devices/system/cpu/cpu1/cache/index0/coherency_line_size
64
```

### 3. Cache映射
主存与cache的地址映射方式有直接映射、全相联方式和组相联方式三种。

具体见：[CPU Cache机制](https://www.shangmayuan.com/a/716ee5808b0b45428fbacbf0.html)

### 4. Cache Miss
当运算器须要从存储器中提取数据时，它首先在最高级的cache中寻找而后在次高级的cache中寻找。若是在cache中找到，则称为命中hit；反之，则称为不命中miss。

**Cache Miss的种类：**

1. Cold Miss：即在程序刚刚启动的时候，数据都是不在缓存中的，所以第一次访问数据必定发生 Miss ，这是不可避免的。
2. Conflict Miss：该Miss是由于不同的内存块映射到同一个cache set导致的。
3. Capacity Miss：容量性未命中，该Miss是由于程序运行所欲的set数量要大于缓存set的数量，导致不能把所有数据都装入缓存中。

更多参考: [Cache Miss与替换策略](https://blog.csdn.net/weixin_43895356/article/details/116606807)

### 5. 替换策略
出现 Miss 后，就需要在下一级的内存中读取数据，那么就有可能涉及 Cache Line 的替换，就涉及到了 CPU Cache 中的替换策略。

首先由于直接映射中每个地址映射到缓存中的位置都是唯一的，所以从下一级的内存中读取内存块到缓存中的策略就是直接替换

而组相联和全相联中一个内存块被映射到哪个 Cache Line 是不确定的，所以才存在替换策略将缓存中的一些 Cache Line 替换出去

+ 最不常使用（Least-Frequently-Used，LFU）：

    该策略会替换在过去某个时间窗口内引用次数最少的那一行。容易把新加入的块替换掉，且容易让前期频繁访问，后期较少访问的块长期驻留。

+ 最近最少使用（Least-Recently-Used, LRU)：
    
    策略会替换最后一次访问时间最久远的那一行。有较高命中率。

+ 随机替换
    
    随机选择一个 Cache Line 替换出去。随机替换算法在硬件上容易实现，且速度也比前两种算法快。缺点则是降低了命中率和Cache工作效率。